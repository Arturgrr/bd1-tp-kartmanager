// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: corrida.sql

package pgstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCorrida = `-- name: CreateCorrida :one
INSERT INTO corrida (slug, nome, data, pista, categoria_slug, temporada, status)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING slug, nome, data, pista, categoria_slug, temporada, status
`

type CreateCorridaParams struct {
	Slug          string      `json:"slug"`
	Nome          string      `json:"nome"`
	Data          pgtype.Date `json:"data"`
	Pista         string      `json:"pista"`
	CategoriaSlug string      `json:"categoria_slug"`
	Temporada     string      `json:"temporada"`
	Status        string      `json:"status"`
}

func (q *Queries) CreateCorrida(ctx context.Context, arg CreateCorridaParams) (Corrida, error) {
	row := q.db.QueryRow(ctx, createCorrida,
		arg.Slug,
		arg.Nome,
		arg.Data,
		arg.Pista,
		arg.CategoriaSlug,
		arg.Temporada,
		arg.Status,
	)
	var i Corrida
	err := row.Scan(
		&i.Slug,
		&i.Nome,
		&i.Data,
		&i.Pista,
		&i.CategoriaSlug,
		&i.Temporada,
		&i.Status,
	)
	return i, err
}

const getCorridaBySlug = `-- name: GetCorridaBySlug :one
SELECT slug, nome, data, pista, categoria_slug, temporada, status
FROM corrida
WHERE slug = $1
`

func (q *Queries) GetCorridaBySlug(ctx context.Context, slug string) (Corrida, error) {
	row := q.db.QueryRow(ctx, getCorridaBySlug, slug)
	var i Corrida
	err := row.Scan(
		&i.Slug,
		&i.Nome,
		&i.Data,
		&i.Pista,
		&i.CategoriaSlug,
		&i.Temporada,
		&i.Status,
	)
	return i, err
}

const listCorridas = `-- name: ListCorridas :many
SELECT slug, nome, data, pista, categoria_slug, temporada, status
FROM corrida
ORDER BY data DESC
`

func (q *Queries) ListCorridas(ctx context.Context) ([]Corrida, error) {
	rows, err := q.db.Query(ctx, listCorridas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Corrida
	for rows.Next() {
		var i Corrida
		if err := rows.Scan(
			&i.Slug,
			&i.Nome,
			&i.Data,
			&i.Pista,
			&i.CategoriaSlug,
			&i.Temporada,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorridasByCategoria = `-- name: ListCorridasByCategoria :many
SELECT slug, nome, data, pista, categoria_slug, temporada, status
FROM corrida
WHERE categoria_slug = $1
ORDER BY data DESC
`

func (q *Queries) ListCorridasByCategoria(ctx context.Context, categoriaSlug string) ([]Corrida, error) {
	rows, err := q.db.Query(ctx, listCorridasByCategoria, categoriaSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Corrida
	for rows.Next() {
		var i Corrida
		if err := rows.Scan(
			&i.Slug,
			&i.Nome,
			&i.Data,
			&i.Pista,
			&i.CategoriaSlug,
			&i.Temporada,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorridasCompleted = `-- name: ListCorridasCompleted :many
SELECT slug, nome, data, pista, categoria_slug, temporada, status
FROM corrida
WHERE status = 'completed'
ORDER BY data DESC
`

func (q *Queries) ListCorridasCompleted(ctx context.Context) ([]Corrida, error) {
	rows, err := q.db.Query(ctx, listCorridasCompleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Corrida
	for rows.Next() {
		var i Corrida
		if err := rows.Scan(
			&i.Slug,
			&i.Nome,
			&i.Data,
			&i.Pista,
			&i.CategoriaSlug,
			&i.Temporada,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCorridasUpcoming = `-- name: ListCorridasUpcoming :many
SELECT slug, nome, data, pista, categoria_slug, temporada, status
FROM corrida
WHERE status = 'upcoming'
ORDER BY data
`

func (q *Queries) ListCorridasUpcoming(ctx context.Context) ([]Corrida, error) {
	rows, err := q.db.Query(ctx, listCorridasUpcoming)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Corrida
	for rows.Next() {
		var i Corrida
		if err := rows.Scan(
			&i.Slug,
			&i.Nome,
			&i.Data,
			&i.Pista,
			&i.CategoriaSlug,
			&i.Temporada,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
